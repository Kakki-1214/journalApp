// SQLite implementation of DBProvider (wraps existing db.ts functions)
import {
  getUserByProvider,
  getUserById,
  upsertUser,
  createUser,
  issueRefreshToken,
  findValidRefreshToken,
  rotateRefreshToken,
  revokeRefreshToken,
  revokeAllRefreshTokensForUser,
  markRefreshTokenReused,
  db,
  getActiveSubscriptionForUser,
  getLatestSubscriptionForUser,
  upsertActiveSubscription,
  findSubscriptionByPurchaseToken,
  findSubscriptionByOriginalTransactionId,
  runExpirySweep,
  insertJournalEntry,
  listJournalEntries,
  deleteJournalEntry,
  totalJournalBytes,
  addAuditLog,
  addSubscriptionEvent,
  revokeJti,
  isJtiRevoked,
  markWebhookProcessed,
  isWebhookProcessed
} from './db';
import type { DBProvider } from './dbProvider';

export const sqliteProvider: DBProvider = {
  async getUserByProvider(provider, subject) { return getUserByProvider(provider, subject); },
  async getUserById(id) { return getUserById(id); },
  async upsertUser(provider, providerSubject, attrs) { return upsertUser(provider, providerSubject, attrs); },
  async createUser(data) { return createUser(data); },
  async issueRefreshToken(userId, ttlDays, fingerprint) { return issueRefreshToken(userId, ttlDays, fingerprint); },
  async findValidRefreshToken(token) { return findValidRefreshToken(token); },
  async rotateRefreshToken(oldToken, userId) { return rotateRefreshToken(oldToken, userId); },
  async revokeRefreshToken(token) { revokeRefreshToken(token); },
  async revokeAllRefreshTokensForUser(userId) { revokeAllRefreshTokensForUser(userId); },
  async markRefreshTokenReused(token) { markRefreshTokenReused(token); },
  async setRefreshTokenFingerprint(tokenId, fingerprint) { try { db.prepare('UPDATE refresh_tokens SET fingerprint=? WHERE id=? AND (fingerprint IS NULL OR fingerprint="")').run(fingerprint, tokenId); } catch {} },
  async getActiveSubscriptionForUser(userId) { return getActiveSubscriptionForUser(userId); },
  async getLatestSubscriptionForUser(userId) { return getLatestSubscriptionForUser(userId); },
  async upsertActiveSubscription(userId, platform, data) { return upsertActiveSubscription(userId, platform, data); },
  async findSubscriptionByPurchaseToken(token) { return findSubscriptionByPurchaseToken(token); },
  async findSubscriptionByOriginalTransactionId(txId) { return findSubscriptionByOriginalTransactionId(txId); },
  async runExpirySweep() { return runExpirySweep(); },
  async insertJournalEntry(userId, content) { return insertJournalEntry(userId, content); },
  async listJournalEntries(userId, limit, offset) { return listJournalEntries(userId, limit, offset); },
  async deleteJournalEntry(userId, entryId) { deleteJournalEntry(userId, entryId); },
  async totalJournalBytes(userId) { return totalJournalBytes(userId); },
  async addAuditLog(action, userId, meta) { addAuditLog(action, userId, meta); },
  async addSubscriptionEvent(event) { return addSubscriptionEvent(event); },
  async revokeJti(jti, userId) { revokeJti(jti, userId); },
  async isJtiRevoked(jti) { return isJtiRevoked(jti); },
  async markWebhookProcessed(provider, eventId) { return markWebhookProcessed(provider, eventId); },
  async isWebhookProcessed(provider, eventId) { return isWebhookProcessed(provider, eventId); }
};
